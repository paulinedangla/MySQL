-- 1. Subqueries Returning a Single Value --
-- 1.1. In the SELECT clause -- 

-- The hotelier would like to know the evolution of the average price of his rooms compared to his reference rate on January 1, 2000 --

-- a. The average room price for any applicable date can be obtained by :

SELECT 
  TRF_DATE_DEBUT, 
  AVG(TRF_CHB_PRIX) AS MOYENNE
FROM TJ_TRF_CHB
GROUP BY TRF_DATE_DEBUT;

-- b. The reference rate that interests us is visible on the 3rd line of the response. We can get it by specifying the query : --

SELECT 
  AVG(TRF_CHB_PRIX) AS MOYENNE
FROM TJ_TRF_CHB
WHERE TRF_DATE_DEBUT = '2000-01-01';

-- c. To calculate the spread, simply report this number by subtracting it from the average price of the request in example 1 : --

SELECT 
  TRF_DATE_DEBUT, 
  AVG(TRF_CHB_PRIX) - 306.05 AS MOYENNE
FROM TJ_TRF_CHB
GROUP BY TRF_DATE_DEBUT;

-- d. All you have to do now is replace the value 306.50 with the query that generated it : --

SELECT
  TRF_DATE_DEBUT, 
  AVG(TRF_CHB_PRIX) - 
  (
    SELECT AVG(TRF_CHB_PRIX)
    FROM TJ_TRF_CHB
    WHERE TRF_DATE_DEBUT = '2000-01-01'
  ) AS MOYENNE
FROM TJ_TRF_CHB
GROUP BY TRF_DATE_DEBUT;

-- 1.2 In where or having filters -- 

-- First example: we are interested in knowing which rooms on 01/01/2000 had a price close to + or - 10 â‚¬ of the average price on 1/1/2000 --

-- a. We already know that the average price at 1/1/200 of all rooms has already been calculated by the query in example 2 and its value is 306.50. We can therefore formulate the query as follows : --

SELECT 
  CHB_ID, 
  TRF_CHB_PRIX
FROM TJ_TRF_CHB
WHERE  
  TRF_CHB_PRIX BETWEEN 296.5 AND 316.50
  AND TRF_DATE_DEBUT = '2000-01-01';
  
-- b. It looks like you should consider placing the subquery twice. But a little trick due to the properties of the equations will allow us to solve this problem. Indeed, if we subtract the value 306.50 from the price of the room, the query becomes : --

SELECT 
  CHB_ID, 
  TRF_CHB_PRIX
FROM TJ_TRF_CHB
WHERE  
  TRF_CHB_PRIX - 306.50 BETWEEN -10 AND +10
  AND TRF_DATE_DEBUT = '2000-01-01';

-- c. Which, moreover, is the strict statement of the departure. So replacing this sum with the query in example 2 is child's play : --

SELECT 
  CHB_ID, 
  TRF_CHB_PRIX
FROM TJ_TRF_CHB
WHERE 
  TRF_CHB_PRIX - 
    (
    SELECT AVG(TRF_CHB_PRIX)
    FROM TJ_TRF_CHB
    WHERE TRF_DATE_DEBUT = '2000-01-01'
    ) BETWEEN -10 AND +10
  AND TRF_DATE_DEBUT = '2000-01-01';

-- Second example : our hotelier wants to know for which months the occupancy rate of his hotel exceeded 2/3 -- 

-- a. Just count the number of occurrences of the table where reservation information is stored (TJ_CHB_PLN_CLI) --

SELECT 
  EXTRACT(YEAR FROM PLN_JOUR) AS ANNEE, 
  EXTRACT(MONTH FROM PLN_JOUR) AS MOIS, 
  COUNT(*) AS NOMBRE 
FROM TJ_CHB_PLN_CLI
GROUP BY 
  EXTRACT(YEAR FROM PLN_JOUR), 
  EXTRACT(MONTH FROM PLN_JOUR)
ORDER BY 
  ANNEE, 
  MOIS;
  
-- b. Similarly, calculating an occupancy rate of 66.67% consists of counting the rooms and multiplying it by this factor, which gives an occupancy rate per night, which can then be reduced to the month by a badly cut dimension 30 days (accounting reference) : --

SELECT COUNT(*) * 30 * 0.6667 AS TAUX_OCCUPATION_MOYEN
FROM T_CHAMBRE;

-- c. From then on we have the elements to nest our queries. The filtering of an aggregate (statistical calculation) can only be done by the HAVING filter --

SELECT 
  EXTRACT(YEAR FROM PLN_JOUR) AS ANNEE, 
  EXTRACT(MONTH FROM PLN_JOUR) AS MOIS, 
  COUNT(*) AS NOMBRE 
FROM TJ_CHB_PLN_CLI
GROUP BY 
  EXTRACT(YEAR FROM PLN_JOUR), 
  EXTRACT(MONTH FROM PLN_JOUR)
HAVING COUNT(*) &gt; 400.02
ORDER BY 
  ANNEE, 
  MOIS;

-- d. The final touch is to replace the numeric value 400.02 with the query from example 9, remembering the parentheses --

SELECT 
  EXTRACT(YEAR FROM PLN_JOUR) AS ANNEE, 
  EXTRACT(MONTH FROM PLN_JOUR) AS MOIS, 
  COUNT(*) AS NOMBRE 
FROM TJ_CHB_PLN_CLI
GROUP BY 
  EXTRACT(YEAR FROM PLN_JOUR), 
  EXTRACT(MONTH FROM PLN_JOUR)
HAVING COUNT(*) > 
  (
  SELECT COUNT(*) * 30 * 0.6667 
  FROM   T_CHAMBRE
  )
ORDER BY 
  ANNEE, 
  MOIS;

-- 2. In the IN predicate --

-- First example : Mr. BOUVIER comes to reserve a room, and as he does it in advance, he would like to take a room in which he never slept during the year 2001. In this type of case, the negation is made by difference: all the rooms of the hotel LESS the rooms in which Mr. BOUVIER has already slept during the year 2001. --

-- a. Finding the rooms occupied by Mr. BOUVIER during the year 2001 is not very difficult --

SELECT 
  DISTINCT C.CHB_ID 
FROM TJ_CHB_PLN_CLI J J
JOIN T_CLIENT C
  ON J.CLI_ID = C.CLI_ID
WHERE 
  C.CLI_NOM ='BOUVIER'
  AND EXTRACT(YEAR FROM J.PLN_JOUR) = 2001;

-- b. Similarly, finding all the rooms in the hotel is the most basic of requests --

SELECT 
  CHB_ID
FROM T_CHAMBRE;

-- c. Therefore the use of the IN, and more particularly here of the NOT IN, will make it possible to make the link between the two requests --

SELECT 
  CHB_ID
FROM T_CHAMBRE
WHERE CHB_ID NOT IN 
  (
  SELECT DISTINCT C.CHB_ID 
  FROM TJ_CHB_PLN_CLI
  JOIN T_CLIENT C
   ON J.CLI_ID = C.CLI_ID
  WHERE  
    C.CLI_NOM ='BOUVIER'
    AND EXTRACT(YEAR FROM J.PLN_JOUR) = 2001
  );

-- d. It is also possible to use a join for this query --

SELECT 
  DISTINCT H.CHB_ID
FROM T_CHAMBRE H
  LEFT OUTER JOIN TJ_CHB_PLN_CLI J
    ON H.CHB_ID = J.CHB_ID 
  LEFT OUTER JOIN T_CLIENT C
    ON J.CLI_ID = C.CLI_ID AND   CLI_NOM ='BOUVIER'
  AND EXTRACT(YEAR FROM J.PLN_JOUR) = 2001
GROUP  BY 
  H.CHB_ID, 
  J.CHB_ID
HAVING COUNT(C.CLI_ID) = 0
ORDER  BY H.CHB_ID;

-- Second example : The hotel manager would like to know which months (and years) had a number of nights equal to the nights recorded during any month of January --

-- a. To find out the number of overnight stays for the months of January, simply add up the CHB_PLN_CLI_NB_PERS column of the TJ_CHB_PLN_CLI table, as follows --

SELECT 
  COUNT(CHB_PLN_CLI_NB_PERS) AS PERSONNE,
  EXTRACT(YEAR FROM PLN_JOUR) AS ANNEE
FROM TJ_CHB_PLN_CLI
WHERE EXTRACT(MONTH FROM PLN_JOUR) = 1
GROUP BY EXTRACT(YEAR FROM PLN_JOUR);

-- b. Expand count to all months of all years --

SELECT 
  COUNT (CHB_PLN_CLI_NB_PERS) AS PERSONNE,
  EXTRACT(YEAR FROM PLN_JOUR) ANNEE,
  EXTRACT(MONTH FROM PLN_JOUR) MOIS
FROM TJ_CHB_PLN_CLI
GROUP BY 
  EXTRACT(YEAR FROM PLN_JOUR), 
  EXTRACT(MONTH FROM PLN_JOUR);

-- c. Now, to only filter these counts on the values returned by the first query (404, 415, 418), all you have to do is use the HAVING clause as follows --

SELECT 
  COUNT (CHB_PLN_CLI_NB_PERS) AS PERSONNE,
  EXTRACT(YEAR FROM PLN_JOUR) ANNEE,
  EXTRACT(MONTH FROM PLN_JOUR) MOIS
FROM TJ_CHB_PLN_CLI
GROUP BY 
  EXTRACT(YEAR FROM PLN_JOUR), 
  EXTRACT(MONTH FROM PLN_JOUR)
HAVING COUNT (CHB_PLN_CLI_NB_PERS) IN (404, 415, 418);

-- d. All that remains is to replace the content of the last parenthesis located after the IN with the first query to which we only leave the count column in the SELECT clause --

SELECT 
  COUNT (CHB_PLN_CLI_NB_PERS) AS PERSONNE,
  EXTRACT(YEAR FROM PLN_JOUR) ANNEE,
  EXTRACT(MONTH FROM PLN_JOUR) MOIS
FROM TJ_CHB_PLN_CLI
GROUP BY 
  EXTRACT(YEAR FROM PLN_JOUR), 
  EXTRACT(MONTH FROM PLN_JOUR)
HAVING COUNT (CHB_PLN_CLI_NB_PERS) IN 
  (
  SELECT COUNT (CHB_PLN_CLI_NB_PERS)
  FROM TJ_CHB_PLN_CLI
  WHERE EXTRACT(MONTH FROM PLN_JOUR) = 1
  GROUP BY EXTRACT(YEAR FROM PLN_JOUR),
  EXTRACT(MONTH FROM PLN_JOUR)
  );

-- 2.2 In ALL, ANY(SOME) predicates --






